<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGIS Pantai Utara Jawa - Demak</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Georaster Layer for Leaflet -->
    <script src="https://unpkg.com/georaster@1.6.0/dist/georaster.browser.bundle.min.js"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet@3.10.0/dist/georaster-layer-for-leaflet.min.js"></script>
    
    <!-- Parse GeoRaster -->
    <script src="https://unpkg.com/geotiff@2.0.7/dist-browser/geotiff.js"></script>
    
    <!-- Geoblaze for raster analysis -->
    <script src="https://unpkg.com/geoblaze@2.8.0/dist/geoblaze.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        @keyframes slideIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .slide-in {
            animation: slideIn 0.3s ease-out;
        }
        
        .fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        
        .layer-item {
            transition: all 0.2s ease;
        }
        
        .layer-item:hover {
            transform: translateX(4px);
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.3);
        }
        
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: #1a202c;
        }
        
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 2px 0 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        
        .sidebar.hidden {
            transform: translateX(-100%);
        }
        
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #1f2937;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        
        .toggle-btn {
            transition: all 0.3s ease;
        }
        
        .toggle-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
        }
        
        .category-header {
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(10px);
        }
        
        .loading-spinner {
            border: 3px solid rgba(59, 130, 246, 0.3);
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Responsive adjustments */
        @media (max-width: 1024px) {
            .sidebar {
                width: 350px !important;
            }
        }
        
        @media (max-width: 768px) {
            .sidebar {
                width: 100% !important;
                max-width: 340px;
            }
            
            #mapLegend {
                bottom: 1rem !important;
                right: 1rem !important;
                left: 1rem !important;
                max-width: none !important;
            }
            
            #coordinates {
                font-size: 11px !important;
                padding: 0.5rem !important;
            }
            
            .sidebar-header h1 {
                font-size: 1.125rem !important;
            }
            
            .sidebar-header p {
                font-size: 0.75rem !important;
            }
        }
        
        @media (max-width: 480px) {
            .sidebar {
                max-width: 300px;
            }
            
            #toggleSidebar {
                top: 0.75rem !important;
                left: 0.75rem !important;
                padding: 0.625rem !important;
            }
            
            #coordinates {
                top: 0.75rem !important;
                right: 0.75rem !important;
                font-size: 10px !important;
            }
            
            .sidebar-header h1 {
                font-size: 1rem !important;
            }
        }
        
        @media (max-width: 360px) {
            .sidebar {
                max-width: 280px;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden">
    
    <!-- Map Container -->
    <div id="map"></div>
    
    <!-- Toggle Sidebar Button -->
    <button 
        id="toggleSidebar" 
        class="toggle-btn fixed top-4 left-4 z-[1001] bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white p-3 rounded-lg shadow-xl transition-all"
        title="Toggle Sidebar"
    >
        <svg id="menuIcon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
        <svg id="closeIcon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
        </svg>
    </button>
    
    <!-- Sidebar -->
    <div id="sidebar" class="sidebar w-96 bg-gray-800">
        <!-- Header -->
        <div class="sidebar-header p-5 border-b border-gray-700 bg-gradient-to-br from-blue-600 via-blue-700 to-blue-800 shadow-lg">
            <h1 class="text-xl font-bold mb-2 leading-tight">WebGIS Prediksi Evolusi Garis Pantai & Karbon Biru</h1>
            <p class="text-sm text-blue-100 flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
                </svg>
                Kabupaten Demak, Jawa Tengah
            </p>
        </div>
        
        <!-- Search Box -->
        <div class="p-4 border-b border-gray-700 bg-gray-750">
            <div class="relative">
                <input 
                    type="text" 
                    id="searchLayer" 
                    placeholder="üîç Cari layer..." 
                    class="w-full px-4 py-2.5 pl-10 bg-gray-700 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm transition-all"
                />
                <svg class="w-5 h-5 absolute left-3 top-2.5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                </svg>
            </div>
        </div>
        
        <!-- Layer Controls -->
        <div class="flex-1 overflow-y-auto">
            <div class="p-4">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-lg font-semibold text-blue-400">Layers Tersedia</h2>
                    <span id="layerCount" class="text-xs bg-blue-600 px-2.5 py-1 rounded-full font-semibold">0</span>
                </div>
                
                <div id="layerList" class="space-y-3">
                    <!-- Layers will be populated here -->
                </div>
            </div>
        </div>
        
        <!-- Info Panel -->
        <div class="p-4 border-t border-gray-700 bg-gray-750">
            <h3 class="text-sm font-semibold mb-3 text-gray-300 flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                </svg>
                Statistik
            </h3>
            <div class="grid grid-cols-2 gap-3 text-xs">
                <div class="bg-gray-700 p-3 rounded-lg">
                    <div class="text-gray-400 mb-1">Layer Aktif</div>
                    <div id="activeLayersCount" class="text-2xl text-green-400 font-bold">0</div>
                </div>
                <div class="bg-gray-700 p-3 rounded-lg">
                    <div class="text-gray-400 mb-1">Total Layer</div>
                    <div id="totalLayersCount" class="text-2xl text-blue-400 font-bold">0</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Map Legend -->
    <div id="mapLegend" class="fixed bottom-24 right-6 z-[999] bg-gray-800 bg-opacity-95 backdrop-blur-sm p-4 rounded-xl shadow-2xl max-w-xs border border-gray-700 hidden">
        <h3 class="text-sm font-bold mb-3 text-blue-400 flex items-center gap-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343l1.657-1.657a2 2 0 012.828 0l2.829 2.829a2 2 0 010 2.828l-8.486 8.485M7 17h.01"/>
            </svg>
            Legend
        </h3>
        <div id="legendContent" class="text-xs space-y-2.5">
            <!-- Legend will be populated dynamically -->
        </div>
    </div>
    
    <!-- Coordinate Display -->
    <div id="coordinates" class="fixed top-4 right-4 z-[999] bg-gray-800 bg-opacity-95 backdrop-blur-sm px-4 py-2.5 rounded-lg shadow-xl border border-gray-700 text-xs">
        <div class="flex items-center gap-2">
            <svg class="w-4 h-4 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
            </svg>
            <span class="text-gray-400 hidden sm:inline">Koordinat: </span>
            <span id="coordValue" class="text-blue-400 font-mono">-</span>
        </div>
    </div>

    <script>
        // Initialize map centered on Demak
        const map = L.map('map', {
            zoomControl: true,
            attributionControl: false
        }).setView([-6.8908, 110.6396], 11);
        
        // Add base layers
        const baseLayers = {
            'Satelit': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Esri',
                maxZoom: 18
            }),
            'Streets': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }),
            'Dark': L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '¬© CartoDB',
                maxZoom: 19
            }),
            'Topografi': L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenTopoMap',
                maxZoom: 17
            })
        };
        
        baseLayers['Satelit'].addTo(map);
        L.control.layers(baseLayers, null, {position: 'topright'}).addTo(map);
        
        // Scale control
        L.control.scale({imperial: false, position: 'bottomleft', maxWidth: 150}).addTo(map);
        
        // Coordinate display
        map.on('mousemove', function(e) {
            const lat = e.latlng.lat.toFixed(6);
            const lng = e.latlng.lng.toFixed(6);
            document.getElementById('coordValue').textContent = `${lat}, ${lng}`;
        });
        
        // Storage for layers
        const layerGroups = {};
        let activeLayerCount = 0;
        
        // Updated list of files based on your data folder
        const dataFiles = [
            // TIF Files
            {
                file: 'data/CVI_Demak.tif',
                name: 'Coastal Vulnerability Index (CVI)',
                info: 'Indeks kerentanan pesisir Demak berdasarkan multiple parameter',
                color: '#f59e0b',
                type: 'tif'
            },
            {
                file: 'data/Emission_Hotspot_Index.tif',
                name: 'Emission Hotspot Index',
                info: 'Hotspot emisi karbon dari degradasi mangrove',
                color: '#ef4444',
                type: 'tif'
            },
            {
                file: 'data/Flood_Demak_2015_2025.tif',
                name: 'Banjir Rob Demak (2015-2025)',
                info: 'Area terdampak banjir rob periode 2015-2025',
                color: '#dc2626',
                type: 'tif'
            },
            {
                file: 'data/Mangrove_Potential_WLC.tif',
                name: 'Potensi Mangrove (WLC)',
                info: 'Zona potensial penanaman mangrove menggunakan Weighted Linear Combination',
                color: '#22c55e',
                type: 'tif'
            },
            {
                file: 'data/Restoration_Index.tif',
                name: 'Indeks Restorasi',
                info: 'Area prioritas restorasi mangrove',
                color: '#14b8a6',
                type: 'tif'
            },
            {
                file: 'data/Seqestration_Hotspot.tif',
                name: 'Sequestration Hotspot',
                info: 'Hotspot potensi sekuestrasi karbon oleh mangrove',
                color: '#10b981',
                type: 'tif'
            },
            {
                file: 'data/Subsidence_Demak_Sim.tif',
                name: 'Simulasi Subsidence Demak',
                info: 'Simulasi penurunan muka tanah (land subsidence) dalam cm/tahun',
                color: '#eab308',
                type: 'tif'
            },
            {
                file: 'data/Zona_Rawan_Intrusi_Pantura.tif',
                name: 'Zona Rawan Intrusi Air Laut',
                info: 'Area rawan intrusi air laut di Pantura (elevasi <5m, jarak <5km dari pantai)',
                color: '#ea580c',
                type: 'tif'
            },
            
            // GeoJSON Files
            {
                file: 'data/LLR.geojson',
                name: 'Linear Regression Rate (LLR)',
                info: 'Analisis laju perubahan garis pantai menggunakan Linear Regression',
                color: '#3b82f6',
                type: 'geojson'
            },
            {
                file: 'data/Tahun35.geojson',
                name: 'Prediksi Garis Pantai 2035',
                info: 'Prediksi posisi garis pantai tahun 2035',
                color: '#1d4ed8',
                type: 'geojson'
            },
            {
                file: 'data/Tahun45.geojson',
                name: 'Prediksi Garis Pantai 2045',
                info: 'Prediksi posisi garis pantai tahun 2045',
                color: '#1e40af',
                type: 'geojson'
            }
        ];
        
        // Category mapping
        const categories = {
            'Garis Pantai & Dinamika': {
                keywords: ['LLR', 'Tahun35', 'Tahun45', 'Linear'],
                icon: 'üåä',
                color: 'blue'
            },
            'Risiko Bencana': {
                keywords: ['CVI', 'Flood', 'Subsidence', 'Intrusi', 'Rawan'],
                icon: '‚ö†Ô∏è',
                color: 'red'
            },
            'Vegetasi & Karbon Biru': {
                keywords: ['Mangrove', 'Emission', 'Seqestration', 'Restoration', 'Potential'],
                icon: 'üå≥',
                color: 'green'
            }
        };
        
        function getCategoryForFile(filename) {
            for (const [category, data] of Object.entries(categories)) {
                if (data.keywords.some(keyword => filename.toLowerCase().includes(keyword.toLowerCase()))) {
                    return category;
                }
            }
            return 'Lainnya';
        }
        
        // Populate layer list
        function populateLayerList() {
            const layerList = document.getElementById('layerList');
            const categorized = {};
            
            // Categorize files
            dataFiles.forEach(item => {
                const category = getCategoryForFile(item.file);
                if (!categorized[category]) {
                    categorized[category] = [];
                }
                categorized[category].push(item);
            });
            
            // Create layer items by category
            Object.entries(categorized).forEach(([category, items]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'mb-4';
                
                const categoryData = categories[category] || {icon: 'üìÅ', color: 'gray'};
                
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'category-header flex items-center gap-2 mb-2.5 p-2 bg-gray-750 rounded-lg text-sm font-semibold text-gray-200';
                categoryHeader.innerHTML = `
                    <span class="text-lg">${categoryData.icon}</span>
                    <span class="flex-1">${category}</span>
                    <span class="text-xs bg-gray-600 px-2 py-0.5 rounded-full">${items.length}</span>
                `;
                categoryDiv.appendChild(categoryHeader);
                
                items.forEach(item => {
                    const layerItem = document.createElement('div');
                    layerItem.className = 'layer-item flex items-center gap-3 p-3 bg-gray-700 rounded-lg cursor-pointer ml-2';
                    layerItem.dataset.filename = item.file;
                    
                    const fileTypeIcon = item.type === 'geojson' ? 'üìç' : 'üó∫Ô∏è';
                    
                    layerItem.innerHTML = `
                        <div class="flex items-center justify-center">
                            <input type="checkbox" id="layer_${item.file.replace(/[^a-zA-Z0-9]/g, '_')}" class="w-4 h-4 text-blue-600 rounded focus:ring-2 focus:ring-blue-500 cursor-pointer">
                        </div>
                        <div class="w-3 h-3 rounded-full flex-shrink-0" style="background-color: ${item.color}"></div>
                        <label for="layer_${item.file.replace(/[^a-zA-Z0-9]/g, '_')}" class="flex-1 cursor-pointer text-sm font-medium">
                            ${item.name}
                        </label>
                        <span class="text-xs opacity-60">${fileTypeIcon}</span>
                        <button class="opacity-btn text-gray-400 hover:text-blue-400 transition-colors p-1 hidden" data-file="${item.file}" title="Opacity">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                            </svg>
                        </button>
                        <button class="info-btn text-gray-400 hover:text-blue-400 transition-colors p-1" data-file="${item.file}" title="Info">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                            </svg>
                        </button>
                    `;
                    
                    const checkbox = layerItem.querySelector('input[type="checkbox"]');
                    checkbox.addEventListener('change', (e) => toggleLayer(item, e.target.checked));
                    
                    const opacityBtn = layerItem.querySelector('.opacity-btn');
                    opacityBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showOpacityControl(item, layerItem);
                    });
                    
                    const infoBtn = layerItem.querySelector('.info-btn');
                    infoBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showLayerInfo(item);
                    });
                    
                    categoryDiv.appendChild(layerItem);
                });
                
                layerList.appendChild(categoryDiv);
            });
            
            document.getElementById('layerCount').textContent = dataFiles.length;
            document.getElementById('totalLayersCount').textContent = dataFiles.length;
        }
        
        // Load GeoJSON
        async function loadGeoJSON(item) {
            try {
                const response = await fetch(item.file);
                if (!response.ok) throw new Error('Failed to load GeoJSON');
                
                const data = await response.json();
                
                const layer = L.geoJSON(data, {
                    style: {
                        color: item.color,
                        weight: 2,
                        opacity: 0.8,
                        fillOpacity: 0.3
                    },
                    onEachFeature: (feature, layer) => {
                        if (feature.properties) {
                            let popupContent = `<div class="p-2"><strong class="text-base">${item.name}</strong><br/>`;
                            for (const [key, value] of Object.entries(feature.properties)) {
                                popupContent += `<span class="text-xs"><strong>${key}:</strong> ${value}</span><br/>`;
                            }
                            popupContent += `</div>`;
                            layer.bindPopup(popupContent);
                        }
                    }
                });
                
                return layer;
            } catch (error) {
                console.error(`Error loading GeoJSON ${item.file}:`, error);
                alert(`Gagal memuat file ${item.name}. Pastikan file ada di folder data/`);
                return null;
            }
        }
        
        // Calculate raster statistics
        async function calculateRasterStats(georaster) {
            try {
                // Use geoblaze to calculate statistics
                const stats = geoblaze.stats(georaster);
                
                return {
                    min: stats[0].min,
                    max: stats[0].max,
                    mean: stats[0].mean,
                    median: stats[0].median,
                    std: stats[0].std
                };
            } catch (error) {
                console.error('Error calculating statistics:', error);
                return null;
            }
        }
        
        // Load GeoTIFF with full implementation
        async function loadGeoTIFF(item) {
            try {
                console.log(`Loading GeoTIFF: ${item.file}`);
                
                // Fetch the GeoTIFF file
                const response = await fetch(item.file);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const arrayBuffer = await response.arrayBuffer();
                
                // Parse GeoTIFF using geotiff.js
                const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
                const image = await tiff.getImage();
                const rasters = await image.readRasters();
                
                // Get georeferencing information
                const bbox = image.getBoundingBox();
                const width = image.getWidth();
                const height = image.getHeight();
                
                console.log(`GeoTIFF Info - Width: ${width}, Height: ${height}, BBox:`, bbox);
                
                // Create georaster object
                const georaster = await parseGeoraster(arrayBuffer);
                
                // Define color scale based on layer type
                const colorScale = getColorScale(item.file);
                
                // Create georaster layer
                const layer = new GeoRasterLayer({
                    georaster: georaster,
                    opacity: 0.7,
                    pixelValuesToColorFn: colorScale,
                    resolution: 256 // Lower resolution for better performance
                });
                
                // Calculate and display statistics
                try {
                    const stats = await calculateRasterStats(georaster);
                    console.log(`Statistics for ${item.name}:`, stats);
                    
                    // Add statistics to layer object for later use
                    layer.stats = stats;
                } catch (err) {
                    console.log('Could not calculate statistics:', err);
                }
                
                // Add click event for pixel value
                layer.on('click', function(event) {
                    const { latlng } = event;
                    const lat = latlng.lat;
                    const lng = latlng.lng;
                    
                    // Get pixel value at clicked location
                    try {
                        const values = geoblaze.identify(georaster, [lng, lat]);
                        if (values && values[0] !== null && values[0] !== undefined) {
                            const value = values[0];
                            let popupContent = `
                                <div class="p-2">
                                    <strong class="text-base">${item.name}</strong>
                                    <p class="text-xs mt-1"><strong>Nilai:</strong> ${value.toFixed(2)}</p>
                                    <p class="text-xs"><strong>Koordinat:</strong> ${lat.toFixed(5)}, ${lng.toFixed(5)}</p>
                            `;
                            
                            // Add statistics if available
                            if (layer.stats) {
                                popupContent += `
                                    <div class="text-xs mt-2 pt-2 border-t border-gray-300">
                                        <strong>Statistik Layer:</strong><br/>
                                        Min: ${layer.stats.min.toFixed(2)}<br/>
                                        Max: ${layer.stats.max.toFixed(2)}<br/>
                                        Mean: ${layer.stats.mean.toFixed(2)}
                                    </div>
                                `;
                            }
                            
                            popupContent += `</div>`;
                            
                            L.popup()
                                .setLatLng(latlng)
                                .setContent(popupContent)
                                .openOn(map);
                        }
                    } catch (err) {
                        console.error('Error getting pixel value:', err);
                    }
                });
                
                return layer;
                
            } catch (error) {
                console.error(`Error loading GeoTIFF ${item.file}:`, error);
                console.error('Error details:', error.message);
                
                // Fallback: Create a placeholder layer with better styling
                console.log('Creating placeholder layer...');
                const bounds = [[-6.95, 110.55], [-6.83, 110.73]];
                const layer = L.rectangle(bounds, {
                    color: item.color,
                    weight: 2,
                    fillColor: item.color,
                    fillOpacity: 0.2,
                    dashArray: '5, 10'
                }).bindPopup(`
                    <div class="p-2">
                        <strong class="text-base">${item.name}</strong>
                        <p class="text-xs mt-1 text-gray-600">${item.info}</p>
                        <p class="text-xs mt-2 text-orange-600">
                            <strong>‚ö†Ô∏è Preview Mode:</strong> File tidak dapat dimuat sepenuhnya.<br/>
                            Kemungkinan penyebab:<br/>
                            ‚Ä¢ File belum tersedia di path: <code>${item.file}</code><br/>
                            ‚Ä¢ Format file tidak sesuai<br/>
                            ‚Ä¢ CORS policy browser
                        </p>
                    </div>
                `);
                
                return layer;
            }
        }
        
        // Get color scale based on layer type
        function getColorScale(filename) {
            const lowerFilename = filename.toLowerCase();
            
            // CVI - Yellow to Red scale (low to high vulnerability)
            if (lowerFilename.includes('cvi')) {
                return values => {
                    const value = values[0];
                    if (value === null || value === undefined || value < 0) return null;
                    if (value <= 1) return '#22c55e'; // Low - Green
                    if (value <= 2) return '#eab308'; // Medium - Yellow
                    if (value <= 3) return '#f97316'; // High - Orange
                    return '#ef4444'; // Very High - Red
                };
            }
            
            // Flood - Blue scale (intensity)
            if (lowerFilename.includes('flood') || lowerFilename.includes('banjir')) {
                return values => {
                    const value = values[0];
                    if (value === null || value === undefined || value === 0) return null;
                    if (value <= 0.3) return '#93c5fd'; // Light blue
                    if (value <= 0.6) return '#3b82f6'; // Blue
                    return '#1e40af'; // Dark blue
                };
            }
            
            // Subsidence - Purple to Red scale
            if (lowerFilename.includes('subsidence') || lowerFilename.includes('penurunan')) {
                return values => {
                    const value = values[0];
                    if (value === null || value === undefined) return null;
                    if (value <= 1) return '#a78bfa'; // Light purple
                    if (value <= 3) return '#8b5cf6'; // Purple
                    if (value <= 5) return '#f97316'; // Orange
                    return '#dc2626'; // Red
                };
            }
            
            // Intrusion - Orange to Red scale
            if (lowerFilename.includes('intrusi') || lowerFilename.includes('intrusion')) {
                return values => {
                    const value = values[0];
                    if (value === null || value === undefined || value === 0) return null;
                    if (value <= 0.3) return '#fed7aa'; // Light orange
                    if (value <= 0.6) return '#fb923c'; // Orange
                    return '#dc2626'; // Red
                };
            }
            
            // Mangrove Potential - Green scale
            if (lowerFilename.includes('mangrove') || lowerFilename.includes('potential')) {
                return values => {
                    const value = values[0];
                    if (value === null || value === undefined || value === 0) return null;
                    if (value <= 0.3) return '#bbf7d0'; // Light green
                    if (value <= 0.6) return '#4ade80'; // Green
                    return '#16a34a'; // Dark green
                };
            }
            
            // Emission Hotspot - Red scale (high emissions)
            if (lowerFilename.includes('emission')) {
                return values => {
                    const value = values[0];
                    if (value === null || value === undefined || value === 0) return null;
                    if (value <= 0.3) return '#fca5a5'; // Light red
                    if (value <= 0.6) return '#f87171'; // Red
                    return '#dc2626'; // Dark red
                };
            }
            
            // Sequestration Hotspot - Green scale (high sequestration)
            if (lowerFilename.includes('seqestration') || lowerFilename.includes('sequestration')) {
                return values => {
                    const value = values[0];
                    if (value === null || value === undefined || value === 0) return null;
                    if (value <= 0.3) return '#86efac'; // Light green
                    if (value <= 0.6) return '#22c55e'; // Green
                    return '#15803d'; // Dark green
                };
            }
            
            // Restoration Index - Teal scale
            if (lowerFilename.includes('restoration') || lowerFilename.includes('restorasi')) {
                return values => {
                    const value = values[0];
                    if (value === null || value === undefined || value === 0) return null;
                    if (value <= 0.3) return '#99f6e4'; // Light teal
                    if (value <= 0.6) return '#2dd4bf'; // Teal
                    return '#0f766e'; // Dark teal
                };
            }
            
            // Default color scale - Blue to Red
            return values => {
                const value = values[0];
                if (value === null || value === undefined) return null;
                
                // Normalize value to 0-1 range (assuming typical range)
                const normalized = Math.min(Math.max(value, 0), 1);
                
                // Create gradient from blue to red
                const r = Math.floor(normalized * 255);
                const g = Math.floor((1 - normalized) * 150);
                const b = Math.floor((1 - normalized) * 255);
                
                return `rgb(${r}, ${g}, ${b})`;
            };
        }
        
        // Toggle layer visibility
        async function toggleLayer(item, visible) {
            const filename = item.file;
            const layerId = filename.replace(/[^a-zA-Z0-9]/g, '_');
            
            if (visible) {
                if (!layerGroups[filename]) {
                    const checkbox = document.getElementById(`layer_${layerId}`);
                    const parent = checkbox.closest('.layer-item');
                    
                    // Show loading state
                    const originalHTML = parent.innerHTML;
                    parent.innerHTML = `
                        <div class="flex items-center gap-2 w-full justify-center">
                            <div class="loading-spinner"></div>
                            <span class="text-sm">Loading ${item.name}...</span>
                        </div>
                    `;
                    parent.style.opacity = '0.8';
                    parent.style.pointerEvents = 'none';
                    
                    try {
                        let layer;
                        if (item.type === 'geojson') {
                            layer = await loadGeoJSON(item);
                        } else if (item.type === 'tif') {
                            layer = await loadGeoTIFF(item);
                        }
                        
                        if (layer) {
                            layerGroups[filename] = layer;
                            layer.addTo(map);
                            activeLayerCount++;
                            
                            // Fit bounds to layer if possible
                            if (layer.getBounds) {
                                map.fitBounds(layer.getBounds(), {padding: [50, 50]});
                            }
                        } else {
                            // Restore checkbox state if loading failed
                            parent.innerHTML = originalHTML;
                            const newCheckbox = parent.querySelector('input[type="checkbox"]');
                            newCheckbox.checked = false;
                            newCheckbox.addEventListener('change', (e) => toggleLayer(item, e.target.checked));
                            const newInfoBtn = parent.querySelector('.info-btn');
                            newInfoBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                showLayerInfo(item);
                            });
                            parent.style.opacity = '1';
                            parent.style.pointerEvents = 'auto';
                            return;
                        }
                    } catch (error) {
                        console.error('Error loading layer:', error);
                        alert(`Terjadi kesalahan saat memuat ${item.name}`);
                    }
                    
                    // Restore original HTML
                    parent.innerHTML = originalHTML;
                    const newCheckbox = parent.querySelector('input[type="checkbox"]');
                    newCheckbox.checked = true;
                    newCheckbox.addEventListener('change', (e) => toggleLayer(item, e.target.checked));
                    const newInfoBtn = parent.querySelector('.info-btn');
                    newInfoBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showLayerInfo(item);
                    });
                    parent.style.opacity = '1';
                    parent.style.pointerEvents = 'auto';
                } else {
                    layerGroups[filename].addTo(map);
                    activeLayerCount++;
                }
            } else {
                if (layerGroups[filename]) {
                    map.removeLayer(layerGroups[filename]);
                    activeLayerCount--;
                    
                    // Hide opacity control button
                    const layerItem = document.querySelector(`[data-filename="${filename}"]`);
                    if (layerItem) {
                        const opacityBtn = layerItem.querySelector('.opacity-btn');
                        if (opacityBtn) opacityBtn.classList.add('hidden');
                    }
                }
            }
            
            document.getElementById('activeLayersCount').textContent = activeLayerCount;
            updateLegend();
        }
        
        // Show opacity control
        function showOpacityControl(item, layerItem) {
            const existingControl = layerItem.querySelector('.opacity-control');
            if (existingControl) {
                existingControl.remove();
                return;
            }
            
            const layer = layerGroups[item.file];
            if (!layer) return;
            
            const currentOpacity = layer.options ? (layer.options.opacity || 0.7) : 0.7;
            
            const opacityControl = document.createElement('div');
            opacityControl.className = 'opacity-control mt-2 p-3 bg-gray-600 rounded-lg';
            opacityControl.innerHTML = `
                <div class="flex items-center gap-2 mb-2">
                    <svg class="w-4 h-4 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                    </svg>
                    <span class="text-xs font-semibold text-gray-200">Opacity</span>
                    <span class="ml-auto text-xs font-mono text-blue-400" id="opacity-value-${item.file.replace(/[^a-zA-Z0-9]/g, '_')}">${Math.round(currentOpacity * 100)}%</span>
                </div>
                <input 
                    type="range" 
                    min="0" 
                    max="100" 
                    value="${currentOpacity * 100}" 
                    class="w-full h-2 bg-gray-500 rounded-lg appearance-none cursor-pointer opacity-slider"
                    style="accent-color: #3b82f6;"
                />
            `;
            
            const slider = opacityControl.querySelector('input[type="range"]');
            const valueDisplay = opacityControl.querySelector(`#opacity-value-${item.file.replace(/[^a-zA-Z0-9]/g, '_')}`);
            
            slider.addEventListener('input', (e) => {
                const opacity = e.target.value / 100;
                valueDisplay.textContent = `${e.target.value}%`;
                
                if (layer.setOpacity) {
                    layer.setOpacity(opacity);
                } else if (layer.setStyle) {
                    layer.setStyle({ opacity: opacity, fillOpacity: opacity * 0.5 });
                }
            });
            
            layerItem.appendChild(opacityControl);
        }
        
        // Show layer info
        function showLayerInfo(item) {
            const fileType = item.type.toUpperCase();
            const fileSize = item.type === 'geojson' ? 'Vector' : 'Raster';
            const info = `üìä ${item.name}\n\n${item.info}\n\nTipe: ${fileType} (${fileSize})\nFile: ${item.file}`;
            alert(info);
        }
        
        // Get legend info for specific layer type
        function getLegendInfo(filename) {
            const lowerFilename = filename.toLowerCase();
            
            if (lowerFilename.includes('cvi')) {
                return {
                    type: 'gradient',
                    items: [
                        { color: '#22c55e', label: 'Rendah (1-2)' },
                        { color: '#eab308', label: 'Sedang (2-3)' },
                        { color: '#f97316', label: 'Tinggi (3-4)' },
                        { color: '#ef4444', label: 'Sangat Tinggi (>4)' }
                    ]
                };
            }
            
            if (lowerFilename.includes('flood') || lowerFilename.includes('banjir')) {
                return {
                    type: 'gradient',
                    items: [
                        { color: '#93c5fd', label: 'Rendah' },
                        { color: '#3b82f6', label: 'Sedang' },
                        { color: '#1e40af', label: 'Tinggi' }
                    ]
                };
            }
            
            if (lowerFilename.includes('subsidence')) {
                return {
                    type: 'gradient',
                    items: [
                        { color: '#a78bfa', label: '<1 cm/tahun' },
                        { color: '#8b5cf6', label: '1-3 cm/tahun' },
                        { color: '#f97316', label: '3-5 cm/tahun' },
                        { color: '#dc2626', label: '>5 cm/tahun' }
                    ]
                };
            }
            
            if (lowerFilename.includes('mangrove') || lowerFilename.includes('potential')) {
                return {
                    type: 'gradient',
                    items: [
                        { color: '#bbf7d0', label: 'Potensi Rendah' },
                        { color: '#4ade80', label: 'Potensi Sedang' },
                        { color: '#16a34a', label: 'Potensi Tinggi' }
                    ]
                };
            }
            
            if (lowerFilename.includes('emission')) {
                return {
                    type: 'gradient',
                    items: [
                        { color: '#fca5a5', label: 'Emisi Rendah' },
                        { color: '#f87171', label: 'Emisi Sedang' },
                        { color: '#dc2626', label: 'Emisi Tinggi' }
                    ]
                };
            }
            
            if (lowerFilename.includes('seqestration') || lowerFilename.includes('sequestration')) {
                return {
                    type: 'gradient',
                    items: [
                        { color: '#86efac', label: 'Sekuestrasi Rendah' },
                        { color: '#22c55e', label: 'Sekuestrasi Sedang' },
                        { color: '#15803d', label: 'Sekuestrasi Tinggi' }
                    ]
                };
            }
            
            if (lowerFilename.includes('restoration') || lowerFilename.includes('restorasi')) {
                return {
                    type: 'gradient',
                    items: [
                        { color: '#99f6e4', label: 'Prioritas Rendah' },
                        { color: '#2dd4bf', label: 'Prioritas Sedang' },
                        { color: '#0f766e', label: 'Prioritas Tinggi' }
                    ]
                };
            }
            
            // Default
            return {
                type: 'single',
                color: '#3b82f6'
            };
        }
        
        // Update legend with detailed information
        function updateLegend() {
            const legend = document.getElementById('mapLegend');
            const legendContent = document.getElementById('legendContent');
            
            const activeLayers = dataFiles.filter(item => 
                layerGroups[item.file] && map.hasLayer(layerGroups[item.file])
            );
            
            if (activeLayers.length > 0) {
                legend.classList.remove('hidden');
                legend.classList.add('fade-in');
                
                legendContent.innerHTML = activeLayers.map(item => {
                    const legendInfo = getLegendInfo(item.file);
                    
                    if (legendInfo.type === 'gradient' && legendInfo.items) {
                        return `
                            <div class="mb-3 pb-3 border-b border-gray-700 last:border-b-0 last:mb-0 last:pb-0">
                                <div class="font-semibold text-xs mb-2 text-gray-200">${item.name}</div>
                                ${legendInfo.items.map(legendItem => `
                                    <div class="flex items-center gap-2 py-1">
                                        <div class="w-4 h-4 rounded flex-shrink-0" style="background-color: ${legendItem.color}"></div>
                                        <span class="text-gray-300 text-xs">${legendItem.label}</span>
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    } else {
                        return `
                            <div class="flex items-center gap-2.5 p-2 bg-gray-700 rounded mb-2">
                                <div class="w-4 h-4 rounded-full flex-shrink-0" style="background-color: ${item.color}"></div>
                                <span class="text-gray-200 text-xs">${item.name}</span>
                            </div>
                        `;
                    }
                }).join('');
            } else {
                legend.classList.add('hidden');
            }
        }
        
        // Enhanced search functionality
        document.getElementById('searchLayer').addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase().trim();
            const layerItems = document.querySelectorAll('.layer-item');
            const categoryDivs = document.querySelectorAll('#layerList > div');
            
            if (searchTerm === '') {
                layerItems.forEach(item => item.style.display = 'flex');
                categoryDivs.forEach(div => div.style.display = 'block');
                return;
            }
            
            const visibleCategories = new Set();
            
            layerItems.forEach(item => {
                const text = item.textContent.toLowerCase();
                const filename = item.dataset.filename.toLowerCase();
                
                if (text.includes(searchTerm) || filename.includes(searchTerm)) {
                    item.style.display = 'flex';
                    visibleCategories.add(item.closest('#layerList > div'));
                } else {
                    item.style.display = 'none';
                }
            });
            
            categoryDivs.forEach(div => {
                if (visibleCategories.has(div)) {
                    div.style.display = 'block';
                } else {
                    div.style.display = 'none';
                }
            });
        });
        
        // Toggle sidebar
        let sidebarVisible = true;
        document.getElementById('toggleSidebar').addEventListener('click', () => {
            const sidebar = document.getElementById('sidebar');
            const menuIcon = document.getElementById('menuIcon');
            const closeIcon = document.getElementById('closeIcon');
            
            sidebarVisible = !sidebarVisible;
            
            if (sidebarVisible) {
                sidebar.classList.remove('hidden');
                menuIcon.classList.remove('hidden');
                closeIcon.classList.add('hidden');
            } else {
                sidebar.classList.add('hidden');
                menuIcon.classList.add('hidden');
                closeIcon.classList.remove('hidden');
            }
            
            // Adjust map after sidebar toggle
            setTimeout(() => map.invalidateSize(), 300);
        });
        
        // Initialize
        populateLayerList();
        
        // Add custom attribution
        const attribution = L.control.attribution({prefix: false, position: 'bottomright'});
        attribution.addAttribution('WebGIS Pantura ¬© 2025 | Data: Sentinel-1/2, SRTM, GMW');
        attribution.addTo(map);
        
        // Responsive map adjustments
        function adjustMapForScreen() {
            const width = window.innerWidth;
            if (width < 768 && sidebarVisible) {
                map.invalidateSize();
            }
        }
        
        window.addEventListener('resize', adjustMapForScreen);
        adjustMapForScreen();
        
        // Console info
        console.log('%cüó∫Ô∏è WebGIS Demak Loaded', 'color: #3b82f6; font-size: 16px; font-weight: bold');
        console.log(`Total layers: ${dataFiles.length}`);
        console.log('Data files:', dataFiles.map(f => f.file));
    </script>

</body>
</html>